var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Simulation_test/Controller1","ref":false,"files":[{"name":"Controller1.c","type":"source","group":"model","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: Controller1.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Controller1.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Controller1_private.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nBlockIO_Controller1_T Controller1_B;\r\n\r\n/* Block states (default storage) */\r\nD_Work_Controller1_T Controller1_DWork;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExternalInputs_Controller1_T Controller1_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExternalOutputs_Controller1_T Controller1_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_Controller1_T Controller1_M_;\r\nRT_MODEL_Controller1_T *const Controller1_M = &Controller1_M_;\r\n\r\n/* System initialize for atomic system: '<S1>/Speed Control' */\r\nvoid Controlle_SpeedControl_Init(rtB_SpeedControl_Controller1_T *localB,\r\n  rtDW_SpeedControl_Controller1_T *localDW)\r\n{\r\n  /* Start for Constant: '<S107>/Ki2' */\r\n  localB->Ki2 = 0.0F;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S144>/Integrator' */\r\n  localDW->Integrator_DSTATE = 0.0F;\r\n  localDW->Integrator_PrevResetState = 0;\r\n}\r\n\r\n/* Output and update for atomic system: '<S1>/Speed Control' */\r\nvoid Controller1_SpeedControl(real32_T rtu_Speed_Ref_PU, real32_T\r\n  rtu_Speed_Meas_PU, rtB_SpeedControl_Controller1_T *localB,\r\n  rtDW_SpeedControl_Controller1_T *localDW)\r\n{\r\n  real32_T u0;\r\n\r\n  /* Logic: '<S107>/Logical Operator' */\r\n  localB->LogicalOperator = false;\r\n\r\n  /* Constant: '<S107>/Ki2' */\r\n  localB->Ki2 = 0.0F;\r\n\r\n  /* DiscreteIntegrator: '<S144>/Integrator' */\r\n  if (localDW->Integrator_PrevResetState != 0) {\r\n    localDW->Integrator_DSTATE = 0.0F;\r\n  }\r\n\r\n  /* DiscreteIntegrator: '<S144>/Integrator' */\r\n  localB->Integrator = localDW->Integrator_DSTATE;\r\n\r\n  /* Switch: '<S108>/Switch' */\r\n  localB->Switch = rtu_Speed_Ref_PU;\r\n\r\n  /* Product: '<S163>/Product' incorporates:\r\n   *  Constant: '<S163>/Filter_Constant'\r\n   */\r\n  localB->Product = localB->Switch * 0.1F;\r\n\r\n  /* UnitDelay: '<S163>/Unit Delay' */\r\n  localB->UnitDelay = localDW->UnitDelay_DSTATE;\r\n\r\n  /* Product: '<S163>/Product1' incorporates:\r\n   *  Constant: '<S163>/One'\r\n   */\r\n  localB->Product1 = 0.9F * localB->UnitDelay;\r\n\r\n  /* Sum: '<S163>/Add1' */\r\n  localB->Add1 = localB->Product + localB->Product1;\r\n\r\n  /* Sum: '<S107>/Sum' */\r\n  localB->Sum = localB->Add1 - rtu_Speed_Meas_PU;\r\n\r\n  /* Product: '<S149>/PProd Out' incorporates:\r\n   *  Constant: '<S107>/Kp1'\r\n   */\r\n  localB->PProdOut = localB->Sum * 2.70955873F;\r\n\r\n  /* Sum: '<S153>/Sum' */\r\n  localB->Sum_g = localB->PProdOut + localB->Integrator;\r\n\r\n  /* Saturate: '<S151>/Saturation' */\r\n  u0 = localB->Sum_g;\r\n  if (u0 > 1.0F) {\r\n    /* Saturate: '<S151>/Saturation' */\r\n    localB->Saturation = 1.0F;\r\n  } else if (u0 < -1.0F) {\r\n    /* Saturate: '<S151>/Saturation' */\r\n    localB->Saturation = -1.0F;\r\n  } else {\r\n    /* Saturate: '<S151>/Saturation' */\r\n    localB->Saturation = u0;\r\n  }\r\n\r\n  /* End of Saturate: '<S151>/Saturation' */\r\n\r\n  /* DeadZone: '<S137>/DeadZone' */\r\n  if (localB->Sum_g > 1.0F) {\r\n    /* DeadZone: '<S137>/DeadZone' */\r\n    localB->DeadZone = localB->Sum_g - 1.0F;\r\n  } else if (localB->Sum_g >= -1.0F) {\r\n    /* DeadZone: '<S137>/DeadZone' */\r\n    localB->DeadZone = 0.0F;\r\n  } else {\r\n    /* DeadZone: '<S137>/DeadZone' */\r\n    localB->DeadZone = localB->Sum_g - -1.0F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S137>/DeadZone' */\r\n\r\n  /* RelationalOperator: '<S135>/Relational Operator' incorporates:\r\n   *  Constant: '<S135>/Clamping_zero'\r\n   */\r\n  localB->RelationalOperator = (localB->DeadZone != 0.0F);\r\n\r\n  /* RelationalOperator: '<S135>/fix for DT propagation issue' incorporates:\r\n   *  Constant: '<S135>/Clamping_zero'\r\n   */\r\n  localB->fixforDTpropagationissue = (localB->DeadZone > 0.0F);\r\n\r\n  /* Switch: '<S135>/Switch1' */\r\n  if (localB->fixforDTpropagationissue) {\r\n    /* Switch: '<S135>/Switch1' incorporates:\r\n     *  Constant: '<S135>/Constant'\r\n     */\r\n    localB->Switch1 = 1;\r\n  } else {\r\n    /* Switch: '<S135>/Switch1' incorporates:\r\n     *  Constant: '<S135>/Constant2'\r\n     */\r\n    localB->Switch1 = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S135>/Switch1' */\r\n\r\n  /* Product: '<S141>/IProd Out' incorporates:\r\n   *  Constant: '<S107>/Ki1'\r\n   */\r\n  localB->IProdOut = localB->Sum * 0.0197651051F;\r\n\r\n  /* RelationalOperator: '<S135>/fix for DT propagation issue1' incorporates:\r\n   *  Constant: '<S135>/Clamping_zero'\r\n   */\r\n  localB->fixforDTpropagationissue1 = (localB->IProdOut > 0.0F);\r\n\r\n  /* Switch: '<S135>/Switch2' */\r\n  if (localB->fixforDTpropagationissue1) {\r\n    /* Switch: '<S135>/Switch2' incorporates:\r\n     *  Constant: '<S135>/Constant3'\r\n     */\r\n    localB->Switch2 = 1;\r\n  } else {\r\n    /* Switch: '<S135>/Switch2' incorporates:\r\n     *  Constant: '<S135>/Constant4'\r\n     */\r\n    localB->Switch2 = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S135>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S135>/Equal1' incorporates:\r\n   *  Switch: '<S135>/Switch1'\r\n   *  Switch: '<S135>/Switch2'\r\n   */\r\n  localB->Equal1 = (localB->Switch1 == localB->Switch2);\r\n\r\n  /* Logic: '<S135>/AND3' */\r\n  localB->AND3 = (localB->RelationalOperator && localB->Equal1);\r\n\r\n  /* Switch: '<S135>/Switch' */\r\n  if (localB->AND3) {\r\n    /* Switch: '<S135>/Switch' incorporates:\r\n     *  Constant: '<S135>/Constant1'\r\n     */\r\n    localB->Switch_l = 0.0F;\r\n  } else {\r\n    /* Switch: '<S135>/Switch' */\r\n    localB->Switch_l = localB->IProdOut;\r\n  }\r\n\r\n  /* End of Switch: '<S135>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S144>/Integrator' */\r\n  localDW->Integrator_DSTATE += localB->Switch_l;\r\n  localDW->Integrator_PrevResetState = 0;\r\n\r\n  /* Update for UnitDelay: '<S163>/Unit Delay' */\r\n  localDW->UnitDelay_DSTATE = localB->Add1;\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid Controller1_step0(void)           /* Sample time: [5.0E-7s, 0.0s] */\r\n{\r\n  int16_T i;\r\n  int16_T tmp;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* RateTransition: '<S1>/RT4' */\r\n  tmp = (int16_T)(Controller1_DWork.RT4_ActiveBufIdx * 6);\r\n  for (i = 0; i < 6; i++) {\r\n    /* Outport: '<Root>/Duty cycles' incorporates:\r\n     *  RateTransition: '<S1>/RT4'\r\n     */\r\n    Controller1_Y.Dutycycles[i] = Controller1_DWork.RT4_Buffer[(int16_T)(i + tmp)];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid Controller1_step1(void)           /* Sample time: [2.5E-5s, 0.0s] */\r\n{\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* RateTransition generated from: '<S1>/RT3' incorporates:\r\n   *  Inport: '<Root>/Pos_fb'\r\n   */\r\n  if (Controller1_DWork.RT3_2_semaphoreTaken == 0) {\r\n    Controller1_DWork.RT3_2_Buffer0[0] = Controller1_U.Pos_fb[0];\r\n    Controller1_DWork.RT3_2_Buffer0[1] = Controller1_U.Pos_fb[1];\r\n  }\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' incorporates:\r\n   *  Inport: '<Root>/Iabc_fb'\r\n   */\r\n  if (Controller1_DWork.RT3_1_semaphoreTaken == 0) {\r\n    Controller1_DWork.RT3_1_Buffer0[0] = Controller1_U.Iabc_fb[0];\r\n    Controller1_DWork.RT3_1_Buffer0[1] = Controller1_U.Iabc_fb[1];\r\n    Controller1_DWork.RT3_1_Buffer0[2] = Controller1_U.Iabc_fb[2];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model step function for TID2 */\r\nvoid Controller1_step2(void)           /* Sample time: [5.0E-5s, 0.0s] */\r\n{\r\n  int32_T Q17perunitconversion;\r\n  real32_T u;\r\n  real32_T u0_0;\r\n  int16_T i;\r\n  uint16_T minV_tmp;\r\n  uint16_T u0;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* RateTransition: '<S1>/RT2' */\r\n  Controller1_B.RT2 =\r\n    Controller1_DWork.RT2_Buffer[Controller1_DWork.RT2_ActiveBufIdx];\r\n\r\n  /* Signum: '<S4>/Sign' */\r\n  u = Controller1_B.RT2;\r\n  if (rtIsNaNF(u)) {\r\n    /* Signum: '<S4>/Sign' */\r\n    Controller1_B.Sign = (rtNaNF);\r\n  } else if (u < 0.0F) {\r\n    /* Signum: '<S4>/Sign' */\r\n    Controller1_B.Sign = -1.0F;\r\n  } else {\r\n    /* Signum: '<S4>/Sign' */\r\n    Controller1_B.Sign = (real32_T)(u > 0.0F);\r\n  }\r\n\r\n  /* End of Signum: '<S4>/Sign' */\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_DWork.RT3_2_semaphoreTaken = 1;\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_B.Pos_fb[0] = Controller1_DWork.RT3_2_Buffer0[0];\r\n  Controller1_B.Pos_fb[1] = Controller1_DWork.RT3_2_Buffer0[1];\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_DWork.RT3_2_semaphoreTaken = 0;\r\n\r\n  /* Outputs for Atomic SubSystem: '<S5>/QEP Feedback' */\r\n  /* Outputs for IfAction SubSystem: '<S84>/PositionNoReset' incorporates:\r\n   *  ActionPort: '<S98>/Action Port'\r\n   */\r\n  /* If: '<S84>/If1' incorporates:\r\n   *  Constant: '<S103>/Constant'\r\n   *  Merge: '<S84>/Merge'\r\n   *  MinMax: '<S98>/MinMax'\r\n   *  Sum: '<S98>/Sum3'\r\n   *  Sum: '<S98>/Sum7'\r\n   */\r\n  Controller1_B.Sum3 = (uint16_T)(Controller1_B.Pos_fb[0] -\r\n    Controller1_B.Pos_fb[1]);\r\n  Controller1_B.Sum7 = (uint16_T)(Controller1_B.Sum3 + 10000U);\r\n  u0 = Controller1_B.Sum3;\r\n  minV_tmp = Controller1_B.Sum7;\r\n  if (u0 <= minV_tmp) {\r\n    minV_tmp = u0;\r\n  }\r\n\r\n  Controller1_B.Merge_p = minV_tmp;\r\n\r\n  /* End of If: '<S84>/If1' */\r\n  /* End of Outputs for SubSystem: '<S84>/PositionNoReset' */\r\n\r\n  /* DataTypeConversion: '<S101>/DTC' */\r\n  Controller1_B.DTC = (real32_T)Controller1_B.Merge_p;\r\n\r\n  /* Product: '<S84>/Product' incorporates:\r\n   *  Constant: '<S104>/Constant'\r\n   */\r\n  Controller1_B.Product = Controller1_B.DTC * 0.0001F;\r\n\r\n  /* Gain: '<S85>/PositionToCount' */\r\n  Controller1_B.PositionToCount = (uint32_T)(4.2949673E+9F *\r\n    Controller1_B.Product);\r\n\r\n  /* Delay: '<S85>/Delay' */\r\n  Controller1_B.Delay =\r\n    Controller1_DWork.Delay_DSTATE[Controller1_DWork.CircBufIdx];\r\n\r\n  /* Sum: '<S85>/SpeedCount' */\r\n  Controller1_B.SpeedCount = (int32_T)((int32_T)Controller1_B.PositionToCount -\r\n    (int32_T)Controller1_B.Delay);\r\n\r\n  /* DataTypeConversion: '<S106>/DTC' */\r\n  Controller1_B.DTC_n = (real32_T)Controller1_B.SpeedCount;\r\n\r\n  /* Gain: '<S85>/SpeedGain' */\r\n  Controller1_B.SpeedGain = 2.70785794E-9F * Controller1_B.DTC_n;\r\n\r\n  /* Product: '<S88>/Product' incorporates:\r\n   *  Constant: '<S88>/Filter_Constant'\r\n   */\r\n  Controller1_B.Product_j = Controller1_B.SpeedGain * 0.01F;\r\n\r\n  /* UnitDelay: '<S88>/Unit Delay' */\r\n  Controller1_B.UnitDelay = Controller1_DWork.UnitDelay_DSTATE;\r\n\r\n  /* Product: '<S88>/Product1' incorporates:\r\n   *  Constant: '<S88>/One'\r\n   */\r\n  Controller1_B.Product1 = 0.99F * Controller1_B.UnitDelay;\r\n\r\n  /* Sum: '<S88>/Add1' */\r\n  Controller1_B.Add1 = Controller1_B.Product_j + Controller1_B.Product1;\r\n\r\n  /* Switch: '<S90>/Switch' incorporates:\r\n   *  Constant: '<S80>/IndexOffset'\r\n   */\r\n  Controller1_B.Switch_e = 0.1995F;\r\n\r\n  /* If: '<S91>/If' */\r\n  if (Controller1_B.Product <= 0.1995F) {\r\n    /* Outputs for IfAction SubSystem: '<S91>/If Action Subsystem' incorporates:\r\n     *  ActionPort: '<S93>/Action Port'\r\n     */\r\n    /* Merge: '<S91>/Merge' incorporates:\r\n     *  Constant: '<S93>/Constant'\r\n     *  Sum: '<S93>/Add'\r\n     */\r\n    Controller1_B.Merge = (Controller1_B.Product + 1.0F) - 0.1995F;\r\n\r\n    /* End of Outputs for SubSystem: '<S91>/If Action Subsystem' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S91>/If Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S94>/Action Port'\r\n     */\r\n    /* Merge: '<S91>/Merge' incorporates:\r\n     *  Sum: '<S94>/Add'\r\n     */\r\n    Controller1_B.Merge = Controller1_B.Product - 0.1995F;\r\n\r\n    /* End of Outputs for SubSystem: '<S91>/If Action Subsystem1' */\r\n  }\r\n\r\n  /* End of If: '<S91>/If' */\r\n\r\n  /* Gain: '<S96>/Number of pole pairs' */\r\n  Controller1_B.Numberofpolepairs = 5.0F * Controller1_B.Merge;\r\n\r\n  /* Rounding: '<S92>/Floor' */\r\n  Controller1_B.Floor = (real32_T)floor((real_T)Controller1_B.Numberofpolepairs);\r\n\r\n  /* Sum: '<S92>/Add' */\r\n  Controller1_B.Add_o = Controller1_B.Numberofpolepairs - Controller1_B.Floor;\r\n\r\n  /* Update for Delay: '<S85>/Delay' */\r\n  Controller1_DWork.Delay_DSTATE[Controller1_DWork.CircBufIdx] =\r\n    Controller1_B.PositionToCount;\r\n  if (Controller1_DWork.CircBufIdx < 19U) {\r\n    Controller1_DWork.CircBufIdx++;\r\n  } else {\r\n    Controller1_DWork.CircBufIdx = 0U;\r\n  }\r\n\r\n  /* End of Update for Delay: '<S85>/Delay' */\r\n\r\n  /* Update for UnitDelay: '<S88>/Unit Delay' */\r\n  Controller1_DWork.UnitDelay_DSTATE = Controller1_B.Add1;\r\n\r\n  /* End of Outputs for SubSystem: '<S5>/QEP Feedback' */\r\n\r\n  /* Outputs for IfAction SubSystem: '<S60>/Position' incorporates:\r\n   *  ActionPort: '<S62>/Action Port'\r\n   */\r\n  /* If: '<S60>/If' incorporates:\r\n   *  If: '<S66>/If'\r\n   */\r\n  if ((Controller1_B.Add_o > 0.0833F) && (Controller1_B.Add_o <= 0.25F)) {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem' incorporates:\r\n     *  ActionPort: '<S67>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  Constant: '<S67>/Constant'\r\n     *  SignalConversion generated from: '<S67>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = 2U;\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem' */\r\n  } else if ((Controller1_B.Add_o > 0.25F) && (Controller1_B.Add_o <= 0.4167F))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem1' incorporates:\r\n     *  ActionPort: '<S68>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  Constant: '<S68>/Constant'\r\n     *  SignalConversion generated from: '<S68>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = 3U;\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem1' */\r\n  } else if ((Controller1_B.Add_o > 0.4167F) && (Controller1_B.Add_o <= 0.5833F))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem2' incorporates:\r\n     *  ActionPort: '<S69>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  Constant: '<S69>/Constant'\r\n     *  SignalConversion generated from: '<S69>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = 4U;\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem2' */\r\n  } else if ((Controller1_B.Add_o > 0.5833F) && (Controller1_B.Add_o <= 0.75F))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem3' incorporates:\r\n     *  ActionPort: '<S70>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  Constant: '<S70>/Constant'\r\n     *  SignalConversion generated from: '<S70>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = 5U;\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem3' */\r\n  } else if ((Controller1_B.Add_o > 0.75F) && (Controller1_B.Add_o <= 0.9167F))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem4' incorporates:\r\n     *  ActionPort: '<S71>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  Constant: '<S71>/Constant'\r\n     *  SignalConversion generated from: '<S71>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = 6U;\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem4' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem6' incorporates:\r\n     *  ActionPort: '<S73>/Action Port'\r\n     */\r\n    /* Outputs for IfAction SubSystem: '<S66>/Enabled Subsystem5' incorporates:\r\n     *  ActionPort: '<S72>/Action Port'\r\n     */\r\n    /* Merge: '<S60>/Merge' incorporates:\r\n     *  SignalConversion generated from: '<S72>/Out1'\r\n     *  SignalConversion generated from: '<S73>/Out1'\r\n     */\r\n    Controller1_B.Merge_i = (uint16_T)((Controller1_B.Add_o > 0.9167F) ||\r\n      (Controller1_B.Add_o <= 0.0833F));\r\n\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem5' */\r\n    /* End of Outputs for SubSystem: '<S66>/Enabled Subsystem6' */\r\n  }\r\n\r\n  /* End of If: '<S60>/If' */\r\n  /* End of Outputs for SubSystem: '<S60>/Position' */\r\n\r\n  /* Outputs for IfAction SubSystem: '<S63>/Bit Extract' incorporates:\r\n   *  ActionPort: '<S74>/Action Port'\r\n   */\r\n  /* If: '<S63>/Range Check' incorporates:\r\n   *  ArithShift: '<S76>/Shift Arithmetic'\r\n   *  ArithShift: '<S76>/Shift Arithmetic1'\r\n   *  DataTypeConversion: '<S76>/Data Type Conversion'\r\n   *  DataTypeConversion: '<S76>/Data Type Conversion1'\r\n   *  DataTypeConversion: '<S76>/Data Type Conversion2'\r\n   *  Logic: '<S76>/AND'\r\n   *  Logic: '<S76>/AND1'\r\n   *  Logic: '<S76>/AND2'\r\n   *  Merge: '<S60>/Merge'\r\n   *  Merge: '<S63>/Merge'\r\n   *  S-Function (sfix_bitop): '<S76>/Bitwise AND1'\r\n   *  S-Function (sfix_bitop): '<S76>/Bitwise AND2'\r\n   *  S-Function (sfix_bitop): '<S76>/Bitwise AND3'\r\n   */\r\n  Controller1_B.ShiftArithmetic = (uint16_T)(Controller1_B.Merge_i >> 2U);\r\n  Controller1_B.A = Controller1_B.ShiftArithmetic;\r\n  Controller1_B.DataTypeConversion_g = (Controller1_B.A != 0U);\r\n  Controller1_B.Merge_l[0] = Controller1_B.DataTypeConversion_g;\r\n  Controller1_B.ShiftArithmetic1 = (uint16_T)(Controller1_B.Merge_i >> 1U);\r\n  Controller1_B.B = (uint16_T)(Controller1_B.ShiftArithmetic1 & 1U);\r\n  Controller1_B.DataTypeConversion1_m = (Controller1_B.B != 0U);\r\n  Controller1_B.Merge_l[1] = Controller1_B.DataTypeConversion1_m;\r\n  Controller1_B.C = (uint16_T)(Controller1_B.Merge_i & 1U);\r\n  Controller1_B.DataTypeConversion2 = (Controller1_B.C != 0U);\r\n  Controller1_B.Merge_l[2] = Controller1_B.DataTypeConversion2;\r\n\r\n  /* End of Outputs for SubSystem: '<S63>/Bit Extract' */\r\n\r\n  /* If: '<S64>/If' */\r\n  if (Controller1_B.Sign > 0.0F) {\r\n    /* Outputs for IfAction SubSystem: '<S64>/positive' incorporates:\r\n     *  ActionPort: '<S78>/Action Port'\r\n     */\r\n    /* CombinatorialLogic: '<S78>/SA1' incorporates:\r\n     *  CombinatorialLogic: '<S78>/SA2'\r\n     *  CombinatorialLogic: '<S78>/SB1'\r\n     *  CombinatorialLogic: '<S78>/SB2'\r\n     *  CombinatorialLogic: '<S78>/SC1'\r\n     *  CombinatorialLogic: '<S78>/SC2'\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    minV_tmp = (uint16_T)Controller1_B.Merge_l[0U];\r\n    minV_tmp = (uint16_T)((uint16_T)(minV_tmp << 1) + (uint16_T)\r\n                          Controller1_B.Merge_l[1U]);\r\n    minV_tmp = (uint16_T)((uint16_T)(minV_tmp << 1) + (uint16_T)\r\n                          Controller1_B.Merge_l[2U]);\r\n    Controller1_B.Merge_d[0] = Controller1_ConstP.pooled7[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S78>/SA2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[1] = Controller1_ConstP.pooled6[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S78>/SB1' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[2] = Controller1_ConstP.pooled9[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S78>/SB2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[3] = Controller1_ConstP.pooled8[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S78>/SC1' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[4] = Controller1_ConstP.pooled11[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S78>/SC2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[5] = Controller1_ConstP.pooled10[minV_tmp];\r\n\r\n    /* End of Outputs for SubSystem: '<S64>/positive' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S64>/negative' incorporates:\r\n     *  ActionPort: '<S77>/Action Port'\r\n     */\r\n    /* CombinatorialLogic: '<S77>/SA1' incorporates:\r\n     *  CombinatorialLogic: '<S77>/SA2'\r\n     *  CombinatorialLogic: '<S77>/SB1'\r\n     *  CombinatorialLogic: '<S77>/SB2'\r\n     *  CombinatorialLogic: '<S77>/SC1'\r\n     *  CombinatorialLogic: '<S77>/SC2'\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    minV_tmp = (uint16_T)Controller1_B.Merge_l[0U];\r\n    minV_tmp = (uint16_T)((uint16_T)(minV_tmp << 1) + (uint16_T)\r\n                          Controller1_B.Merge_l[1U]);\r\n    minV_tmp = (uint16_T)((uint16_T)(minV_tmp << 1) + (uint16_T)\r\n                          Controller1_B.Merge_l[2U]);\r\n    Controller1_B.Merge_d[0] = Controller1_ConstP.pooled6[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S77>/SA2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[1] = Controller1_ConstP.pooled7[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S77>/SB1' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[2] = Controller1_ConstP.pooled8[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S77>/SB2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[3] = Controller1_ConstP.pooled9[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S77>/SC1' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[4] = Controller1_ConstP.pooled10[minV_tmp];\r\n\r\n    /* CombinatorialLogic: '<S77>/SC2' incorporates:\r\n     *  Merge: '<S64>/Merge'\r\n     */\r\n    Controller1_B.Merge_d[5] = Controller1_ConstP.pooled11[minV_tmp];\r\n\r\n    /* End of Outputs for SubSystem: '<S64>/negative' */\r\n  }\r\n\r\n  /* End of If: '<S64>/If' */\r\n  for (i = 0; i < 6; i++) {\r\n    /* DataTypeConversion: '<S4>/Data Type Conversion1' */\r\n    Controller1_B.DataTypeConversion1[i] = (real32_T)Controller1_B.Merge_d[i];\r\n  }\r\n\r\n  /* Abs: '<S4>/Abs' incorporates:\r\n   *  Abs: '<S1>/Abs'\r\n   */\r\n  u = (real32_T)fabs((real_T)Controller1_B.RT2);\r\n\r\n  /* Abs: '<S4>/Abs' */\r\n  Controller1_B.Idc_ref = u;\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_DWork.RT3_1_semaphoreTaken = 1;\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_B.Iabc_fb[0] = Controller1_DWork.RT3_1_Buffer0[0];\r\n  Controller1_B.Iabc_fb[1] = Controller1_DWork.RT3_1_Buffer0[1];\r\n  Controller1_B.Iabc_fb[2] = Controller1_DWork.RT3_1_Buffer0[2];\r\n\r\n  /* RateTransition generated from: '<S1>/RT3' */\r\n  Controller1_DWork.RT3_1_semaphoreTaken = 0;\r\n\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion' */\r\n  Controller1_B.DataTypeConversion[0] = (int32_T)Controller1_B.Iabc_fb[0];\r\n  Controller1_B.DataTypeConversion[1] = (int32_T)Controller1_B.Iabc_fb[1];\r\n  Controller1_B.DataTypeConversion[2] = (int32_T)Controller1_B.Iabc_fb[2];\r\n\r\n  /* Sum: '<S79>/Add' incorporates:\r\n   *  Constant: '<S79>/Constant'\r\n   *  Constant: '<S79>/Constant1'\r\n   *  Constant: '<S79>/Constant2'\r\n   */\r\n  Controller1_B.Add[0] = (real_T)Controller1_B.DataTypeConversion[0] - 3309.0;\r\n  Controller1_B.Add[1] = (real_T)Controller1_B.DataTypeConversion[1] - 3003.0;\r\n  Controller1_B.Add[2] = (real_T)Controller1_B.DataTypeConversion[2] - 3318.0;\r\n\r\n  /* ArithShift: '<S79>/Q17 per unit conversion' incorporates:\r\n   *  Sum: '<S79>/Add'\r\n   */\r\n  Q17perunitconversion = (int32_T)ldexp(Controller1_B.Add[0], 6);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n  Controller1_B.Q17perunitconversion[0] = (real_T)Q17perunitconversion;\r\n\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion3' */\r\n  Controller1_B.DataTypeConversion3[0] = Q17perunitconversion;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion1' incorporates:\r\n   *  DataTypeConversion: '<S79>/Data Type Conversion3'\r\n   */\r\n  Controller1_B.DataTypeConversion1_i[0] = (real32_T)Q17perunitconversion *\r\n    7.62939453E-6F;\r\n\r\n  /* ArithShift: '<S79>/Q17 per unit conversion' incorporates:\r\n   *  Sum: '<S79>/Add'\r\n   */\r\n  Q17perunitconversion = (int32_T)ldexp(Controller1_B.Add[1], 6);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n  Controller1_B.Q17perunitconversion[1] = (real_T)Q17perunitconversion;\r\n\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion3' */\r\n  Controller1_B.DataTypeConversion3[1] = Q17perunitconversion;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion1' incorporates:\r\n   *  DataTypeConversion: '<S79>/Data Type Conversion3'\r\n   */\r\n  Controller1_B.DataTypeConversion1_i[1] = (real32_T)Q17perunitconversion *\r\n    7.62939453E-6F;\r\n\r\n  /* ArithShift: '<S79>/Q17 per unit conversion' incorporates:\r\n   *  Sum: '<S79>/Add'\r\n   */\r\n  Q17perunitconversion = (int32_T)ldexp(Controller1_B.Add[2], 6);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n  Controller1_B.Q17perunitconversion[2] = (real_T)Q17perunitconversion;\r\n\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion3' */\r\n  Controller1_B.DataTypeConversion3[2] = Q17perunitconversion;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* DataTypeConversion: '<S79>/Data Type Conversion1' incorporates:\r\n   *  DataTypeConversion: '<S79>/Data Type Conversion3'\r\n   */\r\n  Controller1_B.DataTypeConversion1_i[2] = (real32_T)Q17perunitconversion *\r\n    7.62939453E-6F;\r\n\r\n  /* Sum: '<S79>/Sum' */\r\n  Controller1_B.Sum = (Controller1_B.DataTypeConversion1_i[0] +\r\n                       Controller1_B.DataTypeConversion1_i[1]) +\r\n    Controller1_B.DataTypeConversion1_i[2];\r\n\r\n  /* Outport: '<Root>/Idc_fb' incorporates:\r\n   *  UnaryMinus: '<S79>/Unary Minus'\r\n   */\r\n  Controller1_Y.Idc_fb = -Controller1_B.Sum;\r\n\r\n  /* Sum: '<S7>/Sum' incorporates:\r\n   *  Outport: '<Root>/Idc_fb'\r\n   */\r\n  Controller1_B.Sum_k = Controller1_B.Idc_ref - Controller1_Y.Idc_fb;\r\n\r\n  /* Product: '<S48>/PProd Out' incorporates:\r\n   *  Constant: '<S7>/Kp'\r\n   */\r\n  Controller1_B.PProdOut = Controller1_B.Sum_k * 1.54862177F;\r\n\r\n  /* Constant: '<S7>/Kp1' */\r\n  Controller1_B.Kp1 = 0.0F;\r\n\r\n  /* DiscreteIntegrator: '<S43>/Integrator' */\r\n  if (Controller1_ConstB.LogicalOperator ||\r\n      (Controller1_DWork.Integrator_PrevResetState != 0)) {\r\n    Controller1_DWork.Integrator_DSTATE = 0.0F;\r\n  }\r\n\r\n  /* DiscreteIntegrator: '<S43>/Integrator' */\r\n  Controller1_B.Integrator = Controller1_DWork.Integrator_DSTATE;\r\n\r\n  /* Sum: '<S52>/Sum' */\r\n  Controller1_B.Sum_m = Controller1_B.PProdOut + Controller1_B.Integrator;\r\n\r\n  /* Saturate: '<S50>/Saturation' */\r\n  u0_0 = Controller1_B.Sum_m;\r\n  if (u0_0 > 1.0F) {\r\n    /* Saturate: '<S50>/Saturation' */\r\n    Controller1_B.Saturation = 1.0F;\r\n  } else if (u0_0 < 0.0F) {\r\n    /* Saturate: '<S50>/Saturation' */\r\n    Controller1_B.Saturation = 0.0F;\r\n  } else {\r\n    /* Saturate: '<S50>/Saturation' */\r\n    Controller1_B.Saturation = u0_0;\r\n  }\r\n\r\n  /* End of Saturate: '<S50>/Saturation' */\r\n  for (i = 0; i < 6; i++) {\r\n    /* Product: '<S4>/Product' */\r\n    u0_0 = Controller1_B.Saturation * Controller1_B.DataTypeConversion1[i];\r\n    Controller1_B.duty[i] = u0_0;\r\n\r\n    /* Switch: '<S6>/Switch1' */\r\n    Controller1_B.Switch1[i] = u0_0;\r\n  }\r\n\r\n  /* DeadZone: '<S36>/DeadZone' */\r\n  if (Controller1_B.Sum_m > 1.0F) {\r\n    /* DeadZone: '<S36>/DeadZone' */\r\n    Controller1_B.DeadZone = Controller1_B.Sum_m - 1.0F;\r\n  } else if (Controller1_B.Sum_m >= 0.0F) {\r\n    /* DeadZone: '<S36>/DeadZone' */\r\n    Controller1_B.DeadZone = 0.0F;\r\n  } else {\r\n    /* DeadZone: '<S36>/DeadZone' */\r\n    Controller1_B.DeadZone = Controller1_B.Sum_m;\r\n  }\r\n\r\n  /* End of DeadZone: '<S36>/DeadZone' */\r\n\r\n  /* RelationalOperator: '<S34>/Relational Operator' incorporates:\r\n   *  Constant: '<S34>/Clamping_zero'\r\n   */\r\n  Controller1_B.RelationalOperator = (Controller1_B.DeadZone != 0.0F);\r\n\r\n  /* RelationalOperator: '<S34>/fix for DT propagation issue' incorporates:\r\n   *  Constant: '<S34>/Clamping_zero'\r\n   */\r\n  Controller1_B.fixforDTpropagationissue = (Controller1_B.DeadZone > 0.0F);\r\n\r\n  /* Switch: '<S34>/Switch1' */\r\n  if (Controller1_B.fixforDTpropagationissue) {\r\n    /* Switch: '<S34>/Switch1' incorporates:\r\n     *  Constant: '<S34>/Constant'\r\n     */\r\n    Controller1_B.Switch1_p = 1;\r\n  } else {\r\n    /* Switch: '<S34>/Switch1' incorporates:\r\n     *  Constant: '<S34>/Constant2'\r\n     */\r\n    Controller1_B.Switch1_p = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S34>/Switch1' */\r\n\r\n  /* Product: '<S40>/IProd Out' incorporates:\r\n   *  Constant: '<S7>/Ki'\r\n   */\r\n  Controller1_B.IProdOut = Controller1_B.Sum_k * 0.0546872728F;\r\n\r\n  /* RelationalOperator: '<S34>/fix for DT propagation issue1' incorporates:\r\n   *  Constant: '<S34>/Clamping_zero'\r\n   */\r\n  Controller1_B.fixforDTpropagationissue1 = (Controller1_B.IProdOut > 0.0F);\r\n\r\n  /* Switch: '<S34>/Switch2' */\r\n  if (Controller1_B.fixforDTpropagationissue1) {\r\n    /* Switch: '<S34>/Switch2' incorporates:\r\n     *  Constant: '<S34>/Constant3'\r\n     */\r\n    Controller1_B.Switch2 = 1;\r\n  } else {\r\n    /* Switch: '<S34>/Switch2' incorporates:\r\n     *  Constant: '<S34>/Constant4'\r\n     */\r\n    Controller1_B.Switch2 = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S34>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S34>/Equal1' incorporates:\r\n   *  Switch: '<S34>/Switch1'\r\n   *  Switch: '<S34>/Switch2'\r\n   */\r\n  Controller1_B.Equal1 = (Controller1_B.Switch1_p == Controller1_B.Switch2);\r\n\r\n  /* Logic: '<S34>/AND3' */\r\n  Controller1_B.AND3 = (Controller1_B.RelationalOperator && Controller1_B.Equal1);\r\n\r\n  /* Switch: '<S34>/Switch' */\r\n  if (Controller1_B.AND3) {\r\n    /* Switch: '<S34>/Switch' incorporates:\r\n     *  Constant: '<S34>/Constant1'\r\n     */\r\n    Controller1_B.Switch = 0.0F;\r\n  } else {\r\n    /* Switch: '<S34>/Switch' */\r\n    Controller1_B.Switch = Controller1_B.IProdOut;\r\n  }\r\n\r\n  /* End of Switch: '<S34>/Switch' */\r\n\r\n  /* RateTransition: '<S1>/RT1' */\r\n  if (Controller1_DWork.RT1_semaphoreTaken == 0) {\r\n    Controller1_DWork.RT1_Buffer0 = Controller1_B.Add1;\r\n  }\r\n\r\n  /* End of RateTransition: '<S1>/RT1' */\r\n\r\n  /* Outport: '<Root>/Idc_Ref' incorporates:\r\n   *  Abs: '<S1>/Abs'\r\n   */\r\n  Controller1_Y.Idc_Ref = u;\r\n\r\n  /* Update for DiscreteIntegrator: '<S43>/Integrator' */\r\n  Controller1_DWork.Integrator_DSTATE += Controller1_B.Switch;\r\n  Controller1_DWork.Integrator_PrevResetState = (int16_T)\r\n    Controller1_ConstB.LogicalOperator;\r\n\r\n  /* Update for RateTransition: '<S1>/RT4' */\r\n  for (i = 0; i < 6; i++) {\r\n    Controller1_DWork.RT4_Buffer[(int16_T)(i + (int16_T)\r\n      ((Controller1_DWork.RT4_ActiveBufIdx == 0) * 6))] =\r\n      Controller1_B.Switch1[i];\r\n  }\r\n\r\n  Controller1_DWork.RT4_ActiveBufIdx = (Controller1_DWork.RT4_ActiveBufIdx == 0);\r\n\r\n  /* End of Update for RateTransition: '<S1>/RT4' */\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model step function for TID3 */\r\nvoid Controller1_step3(void)           /* Sample time: [0.0005s, 0.0s] */\r\n{\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* RateTransition: '<S1>/RT1' */\r\n  Controller1_DWork.RT1_semaphoreTaken = 1;\r\n\r\n  /* Outport: '<Root>/Speed_fb' incorporates:\r\n   *  RateTransition: '<S1>/RT1'\r\n   */\r\n  Controller1_Y.Speed_fb = Controller1_DWork.RT1_Buffer0;\r\n\r\n  /* RateTransition: '<S1>/RT1' */\r\n  Controller1_DWork.RT1_semaphoreTaken = 0;\r\n\r\n  /* Outport: '<Root>/Speed_Ref' incorporates:\r\n   *  Outport: '<Root>/Speed_fb'\r\n   *  RateTransition: '<S1>/RT9'\r\n   */\r\n  Controller1_Y.Speed_Ref =\r\n    Controller1_DWork.RT9_Buffer[Controller1_DWork.RT9_ActiveBufIdx];\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/Speed Control' */\r\n  Controller1_SpeedControl(Controller1_Y.Speed_Ref, Controller1_Y.Speed_fb,\r\n    &Controller1_B.SpeedControl, &Controller1_DWork.SpeedControl);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/Speed Control' */\r\n\r\n  /* Update for RateTransition: '<S1>/RT2' */\r\n  Controller1_DWork.RT2_Buffer[Controller1_DWork.RT2_ActiveBufIdx == 0] =\r\n    Controller1_B.SpeedControl.Saturation;\r\n  Controller1_DWork.RT2_ActiveBufIdx = (Controller1_DWork.RT2_ActiveBufIdx == 0);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model step function for TID4 */\r\nvoid Controller1_step4(void)           /* Sample time: [0.1s, 0.0s] */\r\n{\r\n  /* Outputs for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* Update for RateTransition: '<S1>/RT9' incorporates:\r\n   *  Inport: '<Root>/Speed_Ref_PU'\r\n   */\r\n  Controller1_DWork.RT9_Buffer[Controller1_DWork.RT9_ActiveBufIdx == 0] =\r\n    Controller1_U.Speed_Ref_PU;\r\n  Controller1_DWork.RT9_ActiveBufIdx = (Controller1_DWork.RT9_ActiveBufIdx == 0);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid Controller1_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* Set task counter limit used by the static main program */\r\n  (Controller1_M)->Timing.TaskCounters.cLimit[0] = 1;\r\n  (Controller1_M)->Timing.TaskCounters.cLimit[1] = 50;\r\n  (Controller1_M)->Timing.TaskCounters.cLimit[2] = 100;\r\n  (Controller1_M)->Timing.TaskCounters.cLimit[3] = 1000;\r\n  (Controller1_M)->Timing.TaskCounters.cLimit[4] = 200000;\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(Controller1_M, (NULL));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &Controller1_B), 0,\r\n                sizeof(BlockIO_Controller1_T));\r\n\r\n  {\r\n    int16_T i;\r\n    for (i = 0; i < 6; i++) {\r\n      Controller1_B.DataTypeConversion1[i] = 0.0F;\r\n    }\r\n\r\n    for (i = 0; i < 6; i++) {\r\n      Controller1_B.duty[i] = 0.0F;\r\n    }\r\n\r\n    for (i = 0; i < 6; i++) {\r\n      Controller1_B.Switch1[i] = 0.0F;\r\n    }\r\n\r\n    Controller1_B.Add[0] = 0.0;\r\n    Controller1_B.Add[1] = 0.0;\r\n    Controller1_B.Add[2] = 0.0;\r\n    Controller1_B.Q17perunitconversion[0] = 0.0;\r\n    Controller1_B.Q17perunitconversion[1] = 0.0;\r\n    Controller1_B.Q17perunitconversion[2] = 0.0;\r\n    Controller1_B.RT2 = 0.0F;\r\n    Controller1_B.Sign = 0.0F;\r\n    Controller1_B.Idc_ref = 0.0F;\r\n    Controller1_B.DataTypeConversion1_i[0] = 0.0F;\r\n    Controller1_B.DataTypeConversion1_i[1] = 0.0F;\r\n    Controller1_B.DataTypeConversion1_i[2] = 0.0F;\r\n    Controller1_B.Sum = 0.0F;\r\n    Controller1_B.Sum_k = 0.0F;\r\n    Controller1_B.PProdOut = 0.0F;\r\n    Controller1_B.Kp1 = 0.0F;\r\n    Controller1_B.Integrator = 0.0F;\r\n    Controller1_B.Sum_m = 0.0F;\r\n    Controller1_B.Saturation = 0.0F;\r\n    Controller1_B.DeadZone = 0.0F;\r\n    Controller1_B.IProdOut = 0.0F;\r\n    Controller1_B.Switch = 0.0F;\r\n    Controller1_B.DTC = 0.0F;\r\n    Controller1_B.Product = 0.0F;\r\n    Controller1_B.DTC_n = 0.0F;\r\n    Controller1_B.SpeedGain = 0.0F;\r\n    Controller1_B.Product_j = 0.0F;\r\n    Controller1_B.UnitDelay = 0.0F;\r\n    Controller1_B.Product1 = 0.0F;\r\n    Controller1_B.Add1 = 0.0F;\r\n    Controller1_B.Switch_e = 0.0F;\r\n    Controller1_B.Merge = 0.0F;\r\n    Controller1_B.Numberofpolepairs = 0.0F;\r\n    Controller1_B.Floor = 0.0F;\r\n    Controller1_B.Add_o = 0.0F;\r\n    Controller1_B.SpeedControl.Ki2 = 0.0F;\r\n    Controller1_B.SpeedControl.Integrator = 0.0F;\r\n    Controller1_B.SpeedControl.Switch = 0.0F;\r\n    Controller1_B.SpeedControl.Product = 0.0F;\r\n    Controller1_B.SpeedControl.UnitDelay = 0.0F;\r\n    Controller1_B.SpeedControl.Product1 = 0.0F;\r\n    Controller1_B.SpeedControl.Add1 = 0.0F;\r\n    Controller1_B.SpeedControl.Sum = 0.0F;\r\n    Controller1_B.SpeedControl.PProdOut = 0.0F;\r\n    Controller1_B.SpeedControl.Sum_g = 0.0F;\r\n    Controller1_B.SpeedControl.Saturation = 0.0F;\r\n    Controller1_B.SpeedControl.DeadZone = 0.0F;\r\n    Controller1_B.SpeedControl.IProdOut = 0.0F;\r\n    Controller1_B.SpeedControl.Switch_l = 0.0F;\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&Controller1_DWork, 0,\r\n                sizeof(D_Work_Controller1_T));\r\n  Controller1_DWork.Add_DWORK1[0] = 0.0;\r\n  Controller1_DWork.Add_DWORK1[1] = 0.0;\r\n  Controller1_DWork.Add_DWORK1[2] = 0.0;\r\n  Controller1_DWork.Integrator_DSTATE = 0.0F;\r\n  Controller1_DWork.UnitDelay_DSTATE = 0.0F;\r\n  Controller1_DWork.RT2_Buffer[0] = 0.0F;\r\n  Controller1_DWork.RT2_Buffer[1] = 0.0F;\r\n  Controller1_DWork.RT1_Buffer0 = 0.0F;\r\n  Controller1_DWork.RT9_Buffer[0] = 0.0F;\r\n  Controller1_DWork.RT9_Buffer[1] = 0.0F;\r\n\r\n  {\r\n    int16_T i;\r\n    for (i = 0; i < 12; i++) {\r\n      Controller1_DWork.RT4_Buffer[i] = 0.0F;\r\n    }\r\n  }\r\n\r\n  Controller1_DWork.SpeedControl.Integrator_DSTATE = 0.0F;\r\n  Controller1_DWork.SpeedControl.UnitDelay_DSTATE = 0.0F;\r\n\r\n  /* external inputs */\r\n  (void)memset(&Controller1_U, 0, sizeof(ExternalInputs_Controller1_T));\r\n  Controller1_U.Speed_Ref_PU = 0.0F;\r\n\r\n  /* external outputs */\r\n  {\r\n    int16_T i;\r\n    for (i = 0; i < 6; i++) {\r\n      Controller1_Y.Dutycycles[i] = 0.0F;\r\n    }\r\n\r\n    Controller1_Y.Idc_Ref = 0.0F;\r\n    Controller1_Y.Idc_fb = 0.0F;\r\n    Controller1_Y.Speed_Ref = 0.0F;\r\n    Controller1_Y.Speed_fb = 0.0F;\r\n  }\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<Root>/Controller1' */\r\n  /* Start for Constant: '<S7>/Kp1' */\r\n  Controller1_B.Kp1 = 0.0F;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S43>/Integrator' */\r\n  Controller1_DWork.Integrator_DSTATE = 0.0F;\r\n  Controller1_DWork.Integrator_PrevResetState = 0;\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<S5>/QEP Feedback' */\r\n  /* InitializeConditions for Delay: '<S85>/Delay' */\r\n  Controller1_DWork.CircBufIdx = 0U;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S5>/QEP Feedback' */\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<S1>/Speed Control' */\r\n  Controlle_SpeedControl_Init(&Controller1_B.SpeedControl,\r\n    &Controller1_DWork.SpeedControl);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S1>/Speed Control' */\r\n  /* End of SystemInitialize for SubSystem: '<Root>/Controller1' */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid Controller1_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Controller1.h","type":"header","group":"model","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: Controller1.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller1_h_\r\n#define RTW_HEADER_Controller1_h_\r\n#ifndef Controller1_COMMON_INCLUDES_\r\n#define Controller1_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* Controller1_COMMON_INCLUDES_ */\r\n\r\n#include <stddef.h>\r\n#include \"Controller1_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmCounterLimit\r\n#define rtmCounterLimit(rtm, idx)      ((rtm)->Timing.TaskCounters.cLimit[(idx)])\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\n/* Block signals for system '<S1>/Speed Control' */\r\ntypedef struct {\r\n  real32_T Ki2;                        /* '<S107>/Ki2' */\r\n  real32_T Integrator;                 /* '<S144>/Integrator' */\r\n  real32_T Switch;                     /* '<S108>/Switch' */\r\n  real32_T Product;                    /* '<S163>/Product' */\r\n  real32_T UnitDelay;                  /* '<S163>/Unit Delay' */\r\n  real32_T Product1;                   /* '<S163>/Product1' */\r\n  real32_T Add1;                       /* '<S163>/Add1' */\r\n  real32_T Sum;                        /* '<S107>/Sum' */\r\n  real32_T PProdOut;                   /* '<S149>/PProd Out' */\r\n  real32_T Sum_g;                      /* '<S153>/Sum' */\r\n  real32_T Saturation;                 /* '<S151>/Saturation' */\r\n  real32_T DeadZone;                   /* '<S137>/DeadZone' */\r\n  real32_T IProdOut;                   /* '<S141>/IProd Out' */\r\n  real32_T Switch_l;                   /* '<S135>/Switch' */\r\n  int16_T Switch1;                     /* '<S135>/Switch1' */\r\n  int16_T Switch2;                     /* '<S135>/Switch2' */\r\n  boolean_T LogicalOperator;           /* '<S107>/Logical Operator' */\r\n  boolean_T RelationalOperator;        /* '<S135>/Relational Operator' */\r\n  boolean_T fixforDTpropagationissue;/* '<S135>/fix for DT propagation issue' */\r\n  boolean_T fixforDTpropagationissue1;\r\n                                    /* '<S135>/fix for DT propagation issue1' */\r\n  boolean_T Equal1;                    /* '<S135>/Equal1' */\r\n  boolean_T AND3;                      /* '<S135>/AND3' */\r\n} rtB_SpeedControl_Controller1_T;\r\n\r\n/* Block states (default storage) for system '<S1>/Speed Control' */\r\ntypedef struct {\r\n  real32_T Integrator_DSTATE;          /* '<S144>/Integrator' */\r\n  real32_T UnitDelay_DSTATE;           /* '<S163>/Unit Delay' */\r\n  int16_T Integrator_PrevResetState;   /* '<S144>/Integrator' */\r\n} rtDW_SpeedControl_Controller1_T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Add[3];                       /* '<S79>/Add' */\r\n  real_T Q17perunitconversion[3];      /* '<S79>/Q17 per unit conversion' */\r\n  uint32_T PositionToCount;            /* '<S85>/PositionToCount' */\r\n  uint32_T Delay;                      /* '<S85>/Delay' */\r\n  real32_T RT2;                        /* '<S1>/RT2' */\r\n  real32_T Sign;                       /* '<S4>/Sign' */\r\n  real32_T DataTypeConversion1[6];     /* '<S4>/Data Type Conversion1' */\r\n  real32_T Idc_ref;                    /* '<S4>/Abs' */\r\n  real32_T DataTypeConversion1_i[3];   /* '<S79>/Data Type Conversion1' */\r\n  real32_T Sum;                        /* '<S79>/Sum' */\r\n  real32_T Sum_k;                      /* '<S7>/Sum' */\r\n  real32_T PProdOut;                   /* '<S48>/PProd Out' */\r\n  real32_T Kp1;                        /* '<S7>/Kp1' */\r\n  real32_T Integrator;                 /* '<S43>/Integrator' */\r\n  real32_T Sum_m;                      /* '<S52>/Sum' */\r\n  real32_T Saturation;                 /* '<S50>/Saturation' */\r\n  real32_T duty[6];                    /* '<S4>/Product' */\r\n  real32_T Switch1[6];                 /* '<S6>/Switch1' */\r\n  real32_T DeadZone;                   /* '<S36>/DeadZone' */\r\n  real32_T IProdOut;                   /* '<S40>/IProd Out' */\r\n  real32_T Switch;                     /* '<S34>/Switch' */\r\n  real32_T DTC;                        /* '<S101>/DTC' */\r\n  real32_T Product;                    /* '<S84>/Product' */\r\n  real32_T DTC_n;                      /* '<S106>/DTC' */\r\n  real32_T SpeedGain;                  /* '<S85>/SpeedGain' */\r\n  real32_T Product_j;                  /* '<S88>/Product' */\r\n  real32_T UnitDelay;                  /* '<S88>/Unit Delay' */\r\n  real32_T Product1;                   /* '<S88>/Product1' */\r\n  real32_T Add1;                       /* '<S88>/Add1' */\r\n  real32_T Switch_e;                   /* '<S90>/Switch' */\r\n  real32_T Merge;                      /* '<S91>/Merge' */\r\n  real32_T Numberofpolepairs;          /* '<S96>/Number of pole pairs' */\r\n  real32_T Floor;                      /* '<S92>/Floor' */\r\n  real32_T Add_o;                      /* '<S92>/Add' */\r\n  int32_T DataTypeConversion3[3];      /* '<S79>/Data Type Conversion3' */\r\n  int32_T DataTypeConversion[3];       /* '<S79>/Data Type Conversion' */\r\n  int32_T SpeedCount;                  /* '<S85>/SpeedCount' */\r\n  uint16_T Pos_fb[2];                  /* '<S1>/RT3' */\r\n  uint16_T Iabc_fb[3];                 /* '<S1>/RT3' */\r\n  uint16_T Merge_p;                    /* '<S84>/Merge' */\r\n  uint16_T Sum3;                       /* '<S98>/Sum3' */\r\n  uint16_T Sum7;                       /* '<S98>/Sum7' */\r\n  uint16_T Merge_i;                    /* '<S60>/Merge' */\r\n  uint16_T ShiftArithmetic;            /* '<S76>/Shift Arithmetic' */\r\n  uint16_T A;                          /* '<S76>/Bitwise AND1' */\r\n  uint16_T ShiftArithmetic1;           /* '<S76>/Shift Arithmetic1' */\r\n  uint16_T B;                          /* '<S76>/Bitwise AND2' */\r\n  uint16_T C;                          /* '<S76>/Bitwise AND3' */\r\n  int16_T Switch1_p;                   /* '<S34>/Switch1' */\r\n  int16_T Switch2;                     /* '<S34>/Switch2' */\r\n  boolean_T Merge_l[3];                /* '<S63>/Merge' */\r\n  boolean_T Merge_d[6];                /* '<S64>/Merge' */\r\n  boolean_T RelationalOperator;        /* '<S34>/Relational Operator' */\r\n  boolean_T fixforDTpropagationissue; /* '<S34>/fix for DT propagation issue' */\r\n  boolean_T fixforDTpropagationissue1;\r\n                                     /* '<S34>/fix for DT propagation issue1' */\r\n  boolean_T Equal1;                    /* '<S34>/Equal1' */\r\n  boolean_T AND3;                      /* '<S34>/AND3' */\r\n  boolean_T DataTypeConversion_g;      /* '<S76>/Data Type Conversion' */\r\n  boolean_T DataTypeConversion1_m;     /* '<S76>/Data Type Conversion1' */\r\n  boolean_T DataTypeConversion2;       /* '<S76>/Data Type Conversion2' */\r\n  rtB_SpeedControl_Controller1_T SpeedControl;/* '<S1>/Speed Control' */\r\n} BlockIO_Controller1_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T Add_DWORK1[3];                /* '<S79>/Add' */\r\n  real32_T Integrator_DSTATE;          /* '<S43>/Integrator' */\r\n  real32_T UnitDelay_DSTATE;           /* '<S88>/Unit Delay' */\r\n  uint32_T Delay_DSTATE[20];           /* '<S85>/Delay' */\r\n  volatile real32_T RT2_Buffer[2];     /* '<S1>/RT2' */\r\n  volatile real32_T RT1_Buffer0;       /* '<S1>/RT1' */\r\n  volatile real32_T RT9_Buffer[2];     /* '<S1>/RT9' */\r\n  volatile real32_T RT4_Buffer[12];    /* '<S1>/RT4' */\r\n  int32_T SpeedCount_DWORK1;           /* '<S85>/SpeedCount' */\r\n  volatile int16_T RT2_ActiveBufIdx;   /* '<S1>/RT2' */\r\n  volatile int16_T RT3_2_semaphoreTaken;/* '<S1>/RT3' */\r\n  volatile int16_T RT3_1_semaphoreTaken;/* '<S1>/RT3' */\r\n  volatile int16_T RT1_semaphoreTaken; /* '<S1>/RT1' */\r\n  volatile int16_T RT9_ActiveBufIdx;   /* '<S1>/RT9' */\r\n  volatile int16_T RT4_ActiveBufIdx;   /* '<S1>/RT4' */\r\n  volatile uint16_T RT3_2_Buffer0[2];  /* '<S1>/RT3' */\r\n  volatile uint16_T RT3_1_Buffer0[3];  /* '<S1>/RT3' */\r\n  uint16_T CircBufIdx;                 /* '<S85>/Delay' */\r\n  int16_T Integrator_PrevResetState;   /* '<S43>/Integrator' */\r\n  rtDW_SpeedControl_Controller1_T SpeedControl;/* '<S1>/Speed Control' */\r\n} D_Work_Controller1_T;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  const boolean_T LogicalOperator;     /* '<S7>/Logical Operator' */\r\n} ConstBlockIO_Controller1_T;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SA1'\r\n   *   '<S78>/SA2'\r\n   */\r\n  boolean_T pooled6[8];\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SA2'\r\n   *   '<S78>/SA1'\r\n   */\r\n  boolean_T pooled7[8];\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SB1'\r\n   *   '<S78>/SB2'\r\n   */\r\n  boolean_T pooled8[8];\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SB2'\r\n   *   '<S78>/SB1'\r\n   */\r\n  boolean_T pooled9[8];\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SC1'\r\n   *   '<S78>/SC2'\r\n   */\r\n  boolean_T pooled10[8];\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SC2'\r\n   *   '<S78>/SC1'\r\n   */\r\n  boolean_T pooled11[8];\r\n} ConstParam_Controller1_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real32_T Speed_Ref_PU;               /* '<Root>/Speed_Ref_PU' */\r\n  uint16_T Iabc_fb[3];                 /* '<Root>/Iabc_fb' */\r\n  uint16_T Pos_fb[2];                  /* '<Root>/Pos_fb' */\r\n} ExternalInputs_Controller1_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T Dutycycles[6];              /* '<Root>/Duty cycles' */\r\n  real32_T Idc_Ref;                    /* '<Root>/Idc_Ref' */\r\n  real32_T Idc_fb;                     /* '<Root>/Idc_fb' */\r\n  real32_T Speed_Ref;                  /* '<Root>/Speed_Ref' */\r\n  real32_T Speed_fb;                   /* '<Root>/Speed_fb' */\r\n} ExternalOutputs_Controller1_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_Controller1_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    struct {\r\n      uint32_T TID[5];\r\n      uint32_T cLimit[5];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern BlockIO_Controller1_T Controller1_B;\r\n\r\n/* Block states (default storage) */\r\nextern D_Work_Controller1_T Controller1_DWork;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExternalInputs_Controller1_T Controller1_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExternalOutputs_Controller1_T Controller1_Y;\r\nextern const ConstBlockIO_Controller1_T Controller1_ConstB;/* constant block i/o */\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstParam_Controller1_T Controller1_ConstP;\r\n\r\n/* Model entry point functions */\r\nextern void Controller1_initialize(void);\r\nextern void Controller1_step0(void);\r\nextern void Controller1_step1(void);\r\nextern void Controller1_step2(void);\r\nextern void Controller1_step3(void);\r\nextern void Controller1_step4(void);\r\nextern void Controller1_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_Controller1_T *const Controller1_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('Simulation_test/Controller1')    - opens subsystem Simulation_test/Controller1\r\n * hilite_system('Simulation_test/Controller1/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Simulation_test'\r\n * '<S1>'   : 'Simulation_test/Controller1'\r\n * '<S2>'   : 'Simulation_test/Controller1/Current Control'\r\n * '<S3>'   : 'Simulation_test/Controller1/Speed Control'\r\n * '<S4>'   : 'Simulation_test/Controller1/Current Control/Control_System'\r\n * '<S5>'   : 'Simulation_test/Controller1/Current Control/Input Scaling'\r\n * '<S6>'   : 'Simulation_test/Controller1/Current Control/Subsystem1'\r\n * '<S7>'   : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc'\r\n * '<S8>'   : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation'\r\n * '<S9>'   : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset'\r\n * '<S10>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Anti-windup'\r\n * '<S11>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/D Gain'\r\n * '<S12>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Filter'\r\n * '<S13>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Filter ICs'\r\n * '<S14>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/I Gain'\r\n * '<S15>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Ideal P Gain'\r\n * '<S16>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk'\r\n * '<S17>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Integrator'\r\n * '<S18>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Integrator ICs'\r\n * '<S19>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/N Copy'\r\n * '<S20>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/N Gain'\r\n * '<S21>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/P Copy'\r\n * '<S22>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Parallel P Gain'\r\n * '<S23>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Reset Signal'\r\n * '<S24>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Saturation'\r\n * '<S25>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk'\r\n * '<S26>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Sum'\r\n * '<S27>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Sum Fdbk'\r\n * '<S28>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tracking Mode'\r\n * '<S29>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum'\r\n * '<S30>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral'\r\n * '<S31>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain'\r\n * '<S32>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/postSat Signal'\r\n * '<S33>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/preSat Signal'\r\n * '<S34>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel'\r\n * '<S35>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S36>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S37>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/D Gain/Disabled'\r\n * '<S38>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Filter/Disabled'\r\n * '<S39>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Filter ICs/Disabled'\r\n * '<S40>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/I Gain/External Parameters'\r\n * '<S41>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Ideal P Gain/Passthrough'\r\n * '<S42>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk/Disabled'\r\n * '<S43>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Integrator/Discrete'\r\n * '<S44>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Integrator ICs/External IC'\r\n * '<S45>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/N Copy/Disabled wSignal Specification'\r\n * '<S46>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/N Gain/Disabled'\r\n * '<S47>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/P Copy/Disabled'\r\n * '<S48>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Parallel P Gain/External Parameters'\r\n * '<S49>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Reset Signal/External Reset'\r\n * '<S50>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Saturation/Enabled'\r\n * '<S51>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk/Disabled'\r\n * '<S52>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Sum/Sum_PI'\r\n * '<S53>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Sum Fdbk/Disabled'\r\n * '<S54>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tracking Mode/Disabled'\r\n * '<S55>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum/Passthrough'\r\n * '<S56>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral/TsSignalSpecification'\r\n * '<S57>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain/Passthrough'\r\n * '<S58>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/postSat Signal/Forward_Path'\r\n * '<S59>'  : 'Simulation_test/Controller1/Current Control/Control_System/PI_Controller_Idc/Discrete PI Controller  with anti-windup & reset/preSat Signal/Forward_Path'\r\n * '<S60>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation'\r\n * '<S61>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/HALL'\r\n * '<S62>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position'\r\n * '<S63>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Sector2vector'\r\n * '<S64>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/SwitchingSequence'\r\n * '<S65>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant'\r\n * '<S66>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120'\r\n * '<S67>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem'\r\n * '<S68>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem1'\r\n * '<S69>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem2'\r\n * '<S70>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem3'\r\n * '<S71>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem4'\r\n * '<S72>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem5'\r\n * '<S73>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Position/PositionSectorvariant/Sector120/Enabled Subsystem6'\r\n * '<S74>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Sector2vector/Bit Extract'\r\n * '<S75>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Sector2vector/Default '\r\n * '<S76>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/Sector2vector/Bit Extract/Extract Bits'\r\n * '<S77>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/SwitchingSequence/negative'\r\n * '<S78>'  : 'Simulation_test/Controller1/Current Control/Control_System/Pos_Commutation/Six Step Commutation/SwitchingSequence/positive'\r\n * '<S79>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/Convert ADC value to PU'\r\n * '<S80>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback'\r\n * '<S81>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed'\r\n * '<S82>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/IIR Filter'\r\n * '<S83>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position'\r\n * '<S84>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder'\r\n * '<S85>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Speed Measurement'\r\n * '<S86>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/IIR Filter/IIR Filter'\r\n * '<S87>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/IIR Filter/IIR Filter/Low-pass'\r\n * '<S88>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/IIR Filter/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n * '<S89>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec'\r\n * '<S90>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point'\r\n * '<S91>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset'\r\n * '<S92>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec'\r\n * '<S93>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset/If Action Subsystem'\r\n * '<S94>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset/If Action Subsystem1'\r\n * '<S95>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec/Variant Subsystem'\r\n * '<S96>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec/Variant Subsystem/Dialog'\r\n * '<S97>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/DT_Handle'\r\n * '<S98>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset'\r\n * '<S99>'  : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/PositionResetAtIndex'\r\n * '<S100>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/Variant Subsystem'\r\n * '<S101>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/DT_Handle/floating-point'\r\n * '<S102>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset/Variant Subsystem'\r\n * '<S103>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset/Variant Subsystem/Dialog'\r\n * '<S104>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Quadrature Decoder/Variant Subsystem/Dialog'\r\n * '<S105>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Speed Measurement/DT_Handle'\r\n * '<S106>' : 'Simulation_test/Controller1/Current Control/Input Scaling/QEP Feedback/ Calculate Position and Speed/Speed Measurement/DT_Handle/floating-point'\r\n * '<S107>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed'\r\n * '<S108>' : 'Simulation_test/Controller1/Speed Control/Speed_Ref_Selector'\r\n * '<S109>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset'\r\n * '<S110>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Zero_Cancellation'\r\n * '<S111>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup'\r\n * '<S112>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/D Gain'\r\n * '<S113>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter'\r\n * '<S114>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter ICs'\r\n * '<S115>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/I Gain'\r\n * '<S116>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain'\r\n * '<S117>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk'\r\n * '<S118>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator'\r\n * '<S119>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator ICs'\r\n * '<S120>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Copy'\r\n * '<S121>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Gain'\r\n * '<S122>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/P Copy'\r\n * '<S123>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Parallel P Gain'\r\n * '<S124>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Reset Signal'\r\n * '<S125>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation'\r\n * '<S126>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk'\r\n * '<S127>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum'\r\n * '<S128>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum Fdbk'\r\n * '<S129>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode'\r\n * '<S130>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum'\r\n * '<S131>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral'\r\n * '<S132>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain'\r\n * '<S133>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/postSat Signal'\r\n * '<S134>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preSat Signal'\r\n * '<S135>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel'\r\n * '<S136>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S137>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S138>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/D Gain/Disabled'\r\n * '<S139>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter/Disabled'\r\n * '<S140>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter ICs/Disabled'\r\n * '<S141>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/I Gain/External Parameters'\r\n * '<S142>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain/Passthrough'\r\n * '<S143>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk/Disabled'\r\n * '<S144>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator/Discrete'\r\n * '<S145>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator ICs/External IC'\r\n * '<S146>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Copy/Disabled wSignal Specification'\r\n * '<S147>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Gain/Disabled'\r\n * '<S148>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/P Copy/Disabled'\r\n * '<S149>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Parallel P Gain/External Parameters'\r\n * '<S150>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Reset Signal/External Reset'\r\n * '<S151>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation/Enabled'\r\n * '<S152>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk/Disabled'\r\n * '<S153>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum/Sum_PI'\r\n * '<S154>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum Fdbk/Disabled'\r\n * '<S155>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode/Disabled'\r\n * '<S156>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum/Passthrough'\r\n * '<S157>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral/TsSignalSpecification'\r\n * '<S158>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain/Passthrough'\r\n * '<S159>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/postSat Signal/Forward_Path'\r\n * '<S160>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preSat Signal/Forward_Path'\r\n * '<S161>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter'\r\n * '<S162>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter/Low-pass'\r\n * '<S163>' : 'Simulation_test/Controller1/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n */\r\n#endif                                 /* RTW_HEADER_Controller1_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Controller1_private.h","type":"header","group":"model","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: Controller1_private.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller1_private_h_\r\n#define RTW_HEADER_Controller1_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"Controller1.h\"\r\n#include \"Controller1_types.h\"\r\n#ifndef PORTABLE_WORDSIZES\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFFFU) ) || ( SCHAR_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFU) ) || ( INT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFUL) ) || ( LONG_MAX != (0x7FFFFFFFL) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n#endif                                 /* PORTABLE_WORDSIZES */\r\n\r\nextern void Controlle_SpeedControl_Init(rtB_SpeedControl_Controller1_T *localB,\r\n  rtDW_SpeedControl_Controller1_T *localDW);\r\nextern void Controller1_SpeedControl(real32_T rtu_Speed_Ref_PU, real32_T\r\n  rtu_Speed_Meas_PU, rtB_SpeedControl_Controller1_T *localB,\r\n  rtDW_SpeedControl_Controller1_T *localDW);\r\n\r\n#endif                                 /* RTW_HEADER_Controller1_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Controller1_types.h","type":"header","group":"model","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: Controller1_types.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller1_types_h_\r\n#define RTW_HEADER_Controller1_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_Controller1_T RT_MODEL_Controller1_T;\r\n\r\n#endif                                 /* RTW_HEADER_Controller1_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Controller1_data.c","type":"source","group":"data","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * File: Controller1_data.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Controller1.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstBlockIO_Controller1_T Controller1_ConstB = {\r\n  0                                    /* '<S7>/Logical Operator' */\r\n};\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstParam_Controller1_T Controller1_ConstP = {\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SA1'\r\n   *   '<S78>/SA2'\r\n   */\r\n  { false, false, true, true, false, false, false, false },\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SA2'\r\n   *   '<S78>/SA1'\r\n   */\r\n  { false, false, false, false, false, true, true, false },\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SB1'\r\n   *   '<S78>/SB2'\r\n   */\r\n  { false, false, false, false, true, true, false, false },\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SB2'\r\n   *   '<S78>/SB1'\r\n   */\r\n  { false, true, true, false, false, false, false, false },\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SC1'\r\n   *   '<S78>/SC2'\r\n   */\r\n  { false, true, false, false, false, false, true, false },\r\n\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S77>/SC2'\r\n   *   '<S78>/SC1'\r\n   */\r\n  { false, false, false, true, true, false, false, false }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint16_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint16_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint16_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint16_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint16_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.fltVal = value;\r\n        result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                             0x7FF00000 &&\r\n                             ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                              (tmpVal.bitVal.words.wordL != 0) ));\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.fltVal = value;\r\n        result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                             0x7FF00000 &&\r\n                             ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                              (tmpVal.bitVal.words.wordL != 0) ));\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n#ifdef PORTABLE_WORDSIZES              /* PORTABLE_WORDSIZES defined */\r\n\r\n/*=======================================================================*\r\n * Host information\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       long long:  64\r\n *                       native word size:  64\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef short int8_T;\r\ntypedef unsigned short uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned short boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned int ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#else                                  /* PORTABLE_WORDSIZES not defined */\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#endif                                 /* PORTABLE_WORDSIZES */\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.c","type":"source","group":"interface","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * File: rtmodel.c\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtmodel.h\"\r\n\r\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\r\nvoid Controller1_step(int_T tid)\r\n{\r\n  switch (tid) {\r\n   case 0 :\r\n    Controller1_step0();\r\n    break;\r\n\r\n   case 1 :\r\n    Controller1_step1();\r\n    break;\r\n\r\n   case 2 :\r\n    Controller1_step2();\r\n    break;\r\n\r\n   case 3 :\r\n    Controller1_step3();\r\n    break;\r\n\r\n   case 4 :\r\n    Controller1_step4();\r\n    break;\r\n\r\n   default :\r\n    /* do nothing */\r\n    break;\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"D:\\MATLABNhan\\final\\Simulink\\Controller1_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'Controller1'.\r\n *\r\n * Model version                  : 1.16\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue May 13 19:10:27 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"Controller1.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n\r\n/* Model wrapper function */\r\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\r\nextern void Controller1_step(int_T tid);\r\n\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};